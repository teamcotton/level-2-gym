import { uuidv7 } from 'uuidv7'
import { beforeEach, describe, expect, it, vi } from 'vitest'

import { JwtTokenGeneratorService } from '../../../../src/adapters/secondary/services/jwt-token-generator.service.js'
import { UserId } from '../../../../src/domain/value-objects/userID.js'
import { JwtUtil } from '../../../../src/infrastructure/security/jwt.util.js'
import type { JwtUserClaims } from '../../../../src/shared/types/index.js'

// Mock JwtUtil
vi.mock('../../../../src/infrastructure/security/jwt.util.js', () => ({
  JwtUtil: {
    generateToken: vi.fn(),
  },
}))

// Helper function to create mock claims with proper UserIdType
function createMockClaims(email: string, roles?: string[], userId?: string): JwtUserClaims {
  return {
    sub: new UserId(userId || uuidv7()).getValue(),
    email,
    roles,
  }
}

describe('JwtTokenGeneratorService', () => {
  let service: JwtTokenGeneratorService

  beforeEach(() => {
    vi.clearAllMocks()
    service = new JwtTokenGeneratorService()
  })

  describe('constructor', () => {
    it('should create an instance of JwtTokenGeneratorService', () => {
      expect(service).toBeInstanceOf(JwtTokenGeneratorService)
    })

    it('should implement TokenGeneratorPort interface', () => {
      expect(service).toHaveProperty('generateToken')
      expect(typeof service.generateToken).toBe('function')
    })
  })

  describe('generateToken', () => {
    describe('successful token generation', () => {
      it('should generate a token with valid user claims', () => {
        const claims = createMockClaims('test@example.com', ['user'])
        const expectedToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.mock.token'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(expectedToken)

        const result = service.generateToken(claims)

        expect(result).toBe(expectedToken)
        expect(JwtUtil.generateToken).toHaveBeenCalledTimes(1)
        expect(JwtUtil.generateToken).toHaveBeenCalledWith(claims)
      })

      it('should delegate to JwtUtil.generateToken', () => {
        const claims = createMockClaims('another@example.com', ['admin'])
        const mockToken = 'mock.jwt.token.string'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(mockToken)

        service.generateToken(claims)

        expect(JwtUtil.generateToken).toHaveBeenCalledWith(claims)
      })

      it('should return the token generated by JwtUtil', () => {
        const claims = createMockClaims('user@example.com', ['user', 'moderator'])
        const expectedToken = 'expected.token.value'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(expectedToken)

        const result = service.generateToken(claims)

        expect(result).toBe(expectedToken)
      })
    })

    describe('handling different user claims', () => {
      it('should handle user with single role', () => {
        const claims = createMockClaims('single@example.com', ['user'])
        const mockToken = 'token.for.single.role'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(mockToken)

        const result = service.generateToken(claims)

        expect(result).toBe(mockToken)
        expect(JwtUtil.generateToken).toHaveBeenCalledWith(claims)
      })

      it('should handle user with multiple roles', () => {
        const claims = createMockClaims('multi@example.com', ['user', 'admin', 'superadmin'])
        const mockToken = 'token.for.multiple.roles'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(mockToken)

        const result = service.generateToken(claims)

        expect(result).toBe(mockToken)
        expect(JwtUtil.generateToken).toHaveBeenCalledWith(claims)
      })

      it('should handle user with empty roles array', () => {
        const claims = createMockClaims('noroles@example.com', [])
        const mockToken = 'token.without.roles'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(mockToken)

        const result = service.generateToken(claims)

        expect(result).toBe(mockToken)
        expect(JwtUtil.generateToken).toHaveBeenCalledWith(claims)
      })

      it('should handle user with UUID format subject', () => {
        // Generate a valid v7 UUID for testing
        const validUuid = uuidv7()
        const claims = createMockClaims('uuid@example.com', ['user'], validUuid)
        const mockToken = 'token.with.uuid'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(mockToken)

        const result = service.generateToken(claims)

        expect(result).toBe(mockToken)
        expect(JwtUtil.generateToken).toHaveBeenCalledWith(claims)
      })

      it('should handle user with special characters in email', () => {
        const claims = createMockClaims('user+test@sub.domain.example.com', ['user'])
        const mockToken = 'token.with.special.email'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(mockToken)

        const result = service.generateToken(claims)

        expect(result).toBe(mockToken)
        expect(JwtUtil.generateToken).toHaveBeenCalledWith(claims)
      })
    })

    describe('token format validation', () => {
      it('should return a string value', () => {
        const claims = createMockClaims('test@example.com', ['user'])
        const mockToken = 'string.token.value'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(mockToken)

        const result = service.generateToken(claims)

        expect(typeof result).toBe('string')
      })

      it('should return non-empty string', () => {
        const claims = createMockClaims('nonempty@example.com', ['user'])
        const mockToken = 'non.empty.token'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(mockToken)

        const result = service.generateToken(claims)

        expect(result).toBeTruthy()
        expect(result.length).toBeGreaterThan(0)
      })

      it('should handle realistic JWT token format', () => {
        const claims = createMockClaims('realistic@example.com', ['admin'])
        const realisticToken =
          'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyLTc4OSIsImVtYWlsIjoicmVhbGlzdGljQGV4YW1wbGUuY29tIiwicm9sZXMiOlsiYWRtaW4iXSwiaWF0IjoxNjczMDAwMDAwfQ.signature'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(realisticToken)

        const result = service.generateToken(claims)

        expect(result).toBe(realisticToken)
        expect(result).toMatch(/^[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+$/)
      })
    })

    describe('adapter pattern validation', () => {
      it('should act as a proper adapter to JwtUtil', () => {
        const claims = createMockClaims('adapter@example.com', ['user'])
        const mockToken = 'adapter.pattern.token'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(mockToken)

        service.generateToken(claims)

        // Verify the adapter delegates exactly once
        expect(JwtUtil.generateToken).toHaveBeenCalledTimes(1)
        // Verify the adapter passes claims without modification
        expect(JwtUtil.generateToken).toHaveBeenCalledWith(claims)
      })

      it('should not modify claims before passing to JwtUtil', () => {
        const claims = createMockClaims('immutable@example.com', ['user', 'admin'])
        const claimsCopy = { ...claims, roles: claims.roles ? [...claims.roles] : [] }
        const mockToken = 'immutable.claims.token'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(mockToken)

        service.generateToken(claims)

        // Verify claims passed to JwtUtil match original claims
        const callArgs = vi.mocked(JwtUtil.generateToken).mock.calls[0]?.[0]
        expect(callArgs).toEqual(claimsCopy)
      })

      it('should forward return value from JwtUtil without modification', () => {
        const claims = createMockClaims('forward@example.com', ['user'])
        const exactToken = 'exact.unmodified.token.value'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(exactToken)

        const result = service.generateToken(claims)

        expect(result).toBe(exactToken)
        expect(result).toStrictEqual(exactToken)
      })
    })

    describe('multiple invocations', () => {
      it('should generate different tokens for different users', () => {
        const claims1 = createMockClaims('user1@example.com', ['user'])
        const claims2 = createMockClaims('user2@example.com', ['admin'])

        vi.mocked(JwtUtil.generateToken)
          .mockReturnValueOnce('token.for.user1')
          .mockReturnValueOnce('token.for.user2')

        const result1 = service.generateToken(claims1)
        const result2 = service.generateToken(claims2)

        expect(result1).toBe('token.for.user1')
        expect(result2).toBe('token.for.user2')
        expect(JwtUtil.generateToken).toHaveBeenCalledTimes(2)
      })

      it('should handle consecutive calls independently', () => {
        const claims = createMockClaims('consecutive@example.com', ['user'])

        vi.mocked(JwtUtil.generateToken)
          .mockReturnValueOnce('first.token')
          .mockReturnValueOnce('second.token')
          .mockReturnValueOnce('third.token')

        const token1 = service.generateToken(claims)
        const token2 = service.generateToken(claims)
        const token3 = service.generateToken(claims)

        expect(token1).toBe('first.token')
        expect(token2).toBe('second.token')
        expect(token3).toBe('third.token')
        expect(JwtUtil.generateToken).toHaveBeenCalledTimes(3)
      })

      it('should maintain stateless behavior across invocations', () => {
        const claims1 = createMockClaims('stateless1@example.com', ['user'])
        const claims2 = createMockClaims('stateless2@example.com', ['admin'])

        vi.mocked(JwtUtil.generateToken).mockReturnValue('mock.token')

        service.generateToken(claims1)
        service.generateToken(claims2)

        // Verify each call is independent
        const calls = vi.mocked(JwtUtil.generateToken).mock.calls
        expect(calls[0]?.[0]).toEqual(claims1)
        expect(calls[1]?.[0]).toEqual(claims2)
        expect(calls.length).toBe(2)
      })
    })

    describe('integration with port interface', () => {
      it('should satisfy TokenGeneratorPort contract', () => {
        const claims = createMockClaims('port@example.com', ['user'])
        const mockToken = 'port.interface.token'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(mockToken)

        // Should accept JwtUserClaims and return string
        const result: string = service.generateToken(claims)

        expect(typeof result).toBe('string')
        expect(result).toBe(mockToken)
      })

      it('should work with dependency injection', () => {
        // Create a new instance to simulate DI container behavior
        const injectedService = new JwtTokenGeneratorService()
        const claims = createMockClaims('di@example.com', ['user'])
        const mockToken = 'di.container.token'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(mockToken)

        const result = injectedService.generateToken(claims)

        expect(result).toBe(mockToken)
        expect(injectedService).toBeInstanceOf(JwtTokenGeneratorService)
      })
    })
  })
})
