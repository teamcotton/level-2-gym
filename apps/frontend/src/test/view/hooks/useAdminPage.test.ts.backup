import type { GridPaginationModel } from '@mui/x-data-grid'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { act, renderHook, waitFor } from '@testing-library/react'
import React from 'react'
import { beforeEach, describe, expect, it, vi } from 'vitest'

import * as findAllUsersModule from '@/application/actions/findAllUsers.js'
import type { User } from '@/domain/user/user.js'
import { useAdminPage } from '@/view/hooks/useAdminPage.js'

// Mock the findAllUsers action
vi.mock('@/application/actions/findAllUsers.js', () => ({
  findAllUsers: vi.fn(),
}))

const mockFindAllUsers = findAllUsersModule.findAllUsers as ReturnType<typeof vi.fn>

// Helper function to create a QueryClientProvider wrapper
function createWrapper(client: QueryClient) {
  return function Wrapper({ children }: { children: React.ReactNode }) {
    return <QueryClientProvider client={client}>{children}</QueryClientProvider>
  }
}

// Helper function to create AbortError
function createAbortError(): Error {
  const error = new Error('The operation was aborted')
  error.name = 'AbortError'
  return error
}

describe('useAdminPage', () => {
  const mockUsers: readonly User[] = [
    {
      id: '1',
      email: 'admin@example.com',
      name: 'Admin User',
      role: 'admin',
      createdAt: '2024-01-01T00:00:00.000Z',
    },
    {
      id: '2',
      email: 'user@example.com',
      name: 'Regular User',
      role: 'user',
      createdAt: '2024-01-02T00:00:00.000Z',
    },
  ]

  beforeEach(() => {
    vi.clearAllMocks()
  })

  describe('Initial State', () => {
    it('should initialize with empty users array', async () => {
      mockFindAllUsers.mockResolvedValueOnce({
        success: true,
        users: [],
        total: 0,
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.users).toEqual([])
      })
    })

    it('should initialize with loading state as true', async () => {
      mockFindAllUsers.mockResolvedValueOnce({
        success: true,
        users: mockUsers,
        total: 2,
      })

      const { result } = renderHook(() => useAdminPage())

      expect(result.current.loading).toBe(true)
    })

    it('should initialize with no error', async () => {
      mockFindAllUsers.mockResolvedValueOnce({
        success: true,
        users: mockUsers,
        total: 2,
      })

      const { result } = renderHook(() => useAdminPage())
      await waitFor(() => {
        expect(result.current.error).toBeNull()
      })
    })

    it('should initialize with empty search query', () => {
      mockFindAllUsers.mockResolvedValueOnce({
        success: true,
        users: mockUsers,
        total: 2,
      })

      const { result } = renderHook(() => useAdminPage())

      expect(result.current.searchQuery).toBe('')
    })

    it('should initialize with default pagination model', () => {
      mockFindAllUsers.mockResolvedValueOnce({
        success: true,
        users: mockUsers,
        total: 2,
      })

      const { result } = renderHook(() => useAdminPage())

      expect(result.current.paginationModel).toEqual({
        page: 0,
        pageSize: 10,
      })
    })

    it('should initialize with rowCount as 0', async () => {
      mockFindAllUsers.mockResolvedValueOnce({
        success: true,
        users: mockUsers,
        total: 2,
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.rowCount).toBe(0)
      })
    })

    it('should initialize with admin role', () => {
      mockFindAllUsers.mockResolvedValueOnce({
        success: true,
        users: mockUsers,
        total: 2,
      })

      const { result } = renderHook(() => useAdminPage())

      expect(result.current.currentUserRole).toBe('admin')
    })

    it('should provide all required handlers', () => {
      mockFindAllUsers.mockResolvedValueOnce({
        success: true,
        users: mockUsers,
        total: 2,
      })

      const { result } = renderHook(() => useAdminPage())

      expect(result.current.handleSearchChange).toBeDefined()
      expect(result.current.handlePaginationChange).toBeDefined()
      expect(typeof result.current.handleSearchChange).toBe('function')
      expect(typeof result.current.handlePaginationChange).toBe('function')
    })
  })

  describe('Data Fetching - Success Cases', () => {
    it('should fetch users on mount with default pagination', async () => {
      mockFindAllUsers.mockResolvedValueOnce({
        success: true,
        users: mockUsers,
        total: 2,
      })

      renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(mockFindAllUsers).toHaveBeenCalledTimes(1)
        expect(mockFindAllUsers).toHaveBeenCalledWith(
          expect.objectContaining({
            limit: 10,
            offset: 0,
          })
        )
      })
    })

    it('should update users state after successful fetch', async () => {
      mockFindAllUsers.mockResolvedValueOnce({
        success: true,
        users: mockUsers,
        total: 2,
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.users).toEqual(mockUsers)
      })
    })

    it('should update rowCount after successful fetch', async () => {
      mockFindAllUsers.mockResolvedValueOnce({
        success: true,
        users: mockUsers,
        total: 2,
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.rowCount).toBe(2)
      })
    })

    it('should set loading to false after successful fetch', async () => {
      mockFindAllUsers.mockResolvedValueOnce({
        success: true,
        users: mockUsers,
        total: 2,
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.loading).toBe(false)
      })
    })

    it('should clear any previous errors after successful fetch', async () => {
      // First call fails
      mockFindAllUsers.mockResolvedValueOnce({
        success: false,
        users: [],
        total: 0,
        error: 'Network error',
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.error).toBe('Network error')
      })

      // Second call succeeds
      mockFindAllUsers.mockResolvedValueOnce({
        success: true,
        users: mockUsers,
        total: 2,
      })

      // Trigger re-fetch by changing pagination
      act(() => {
        result.current.handlePaginationChange({ page: 1, pageSize: 10 })
      })

      await waitFor(() => {
        expect(result.current.error).toBeNull()
      })
    })

    it('should handle empty user list', async () => {
      mockFindAllUsers.mockResolvedValueOnce({
        success: true,
        users: [],
        total: 0,
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.users).toEqual([])
        expect(result.current.rowCount).toBe(0)
        expect(result.current.loading).toBe(false)
        expect(result.current.error).toBeNull()
      })
    })

    it('should handle large user list', async () => {
      const largeUserList: User[] = Array.from({ length: 100 }, (_, i) => ({
        id: `${i + 1}`,
        email: `user${i + 1}@example.com`,
        name: `User ${i + 1}`,
        role: i % 3 === 0 ? 'admin' : i % 3 === 1 ? 'moderator' : 'user',
        createdAt: '2024-01-01T00:00:00.000Z',
      })) as User[]

      mockFindAllUsers.mockResolvedValueOnce({
        success: true,
        users: largeUserList,
        total: 100,
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.users).toHaveLength(100)
        expect(result.current.rowCount).toBe(100)
      })
    })
  })

  describe('Data Fetching - Error Cases', () => {
    it('should handle fetch failure with error message', async () => {
      mockFindAllUsers.mockResolvedValueOnce({
        success: false,
        users: [],
        total: 0,
        error: 'Failed to fetch users from server',
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.error).toBe('Failed to fetch users from server')
      })
    })

    it('should clear users on fetch failure', async () => {
      mockFindAllUsers.mockResolvedValueOnce({
        success: false,
        users: [],
        total: 0,
        error: 'Network error',
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.users).toEqual([])
      })
    })

    it('should reset rowCount to 0 on fetch failure', async () => {
      mockFindAllUsers.mockResolvedValueOnce({
        success: false,
        users: [],
        total: 0,
        error: 'Server error',
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.rowCount).toBe(0)
      })
    })

    it('should set loading to false after fetch failure', async () => {
      mockFindAllUsers.mockResolvedValueOnce({
        success: false,
        users: [],
        total: 0,
        error: 'Failed to load',
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.loading).toBe(false)
      })
    })

    it('should use fallback error message when error is undefined', async () => {
      mockFindAllUsers.mockResolvedValueOnce({
        success: false,
        users: [],
        total: 0,
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.error).toBe('Failed to load users')
      })
    })

    it('should handle network timeout error', async () => {
      mockFindAllUsers.mockResolvedValueOnce({
        success: false,
        users: [],
        total: 0,
        error: 'Request timeout after 30 seconds',
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.error).toBe('Request timeout after 30 seconds')
        expect(result.current.users).toEqual([])
        expect(result.current.loading).toBe(false)
      })
    })

    it('should handle 404 error', async () => {
      mockFindAllUsers.mockResolvedValueOnce({
        success: false,
        users: [],
        total: 0,
        error: 'HTTP 404: Resource not found',
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.error).toBe('HTTP 404: Resource not found')
      })
    })

    it('should handle 500 server error', async () => {
      mockFindAllUsers.mockResolvedValueOnce({
        success: false,
        users: [],
        total: 0,
        error: 'HTTP 500: Internal server error',
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.error).toBe('HTTP 500: Internal server error')
      })
    })
  })

  describe('Pagination Handling', () => {
    it('should update pagination model when handlePaginationChange is called', async () => {
      mockFindAllUsers.mockResolvedValue({
        success: true,
        users: mockUsers,
        total: 2,
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.loading).toBe(false)
      })

      const newModel: GridPaginationModel = { page: 1, pageSize: 20 }

      act(() => {
        result.current.handlePaginationChange(newModel)
      })

      await waitFor(() => {
        expect(result.current.paginationModel).toEqual(newModel)
      })
    })

    it('should trigger new fetch when pagination changes', async () => {
      mockFindAllUsers.mockResolvedValue({
        success: true,
        users: mockUsers,
        total: 2,
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(mockFindAllUsers).toHaveBeenCalledTimes(1)
      })

      act(() => {
        result.current.handlePaginationChange({ page: 1, pageSize: 10 })
      })

      await waitFor(() => {
        expect(mockFindAllUsers).toHaveBeenCalledTimes(2)
      })
    })

    it('should calculate correct offset when page changes', async () => {
      mockFindAllUsers.mockResolvedValue({
        success: true,
        users: mockUsers,
        total: 2,
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.loading).toBe(false)
      })

      act(() => {
        result.current.handlePaginationChange({ page: 2, pageSize: 10 })
      })

      await waitFor(() => {
        expect(mockFindAllUsers).toHaveBeenCalledWith(
          expect.objectContaining({
            limit: 10,
            offset: 20, // page 2 * pageSize 10
          })
        )
      })
    })

    it('should use correct limit when pageSize changes', async () => {
      mockFindAllUsers.mockResolvedValue({
        success: true,
        users: mockUsers,
        total: 2,
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.loading).toBe(false)
      })

      act(() => {
        result.current.handlePaginationChange({ page: 0, pageSize: 25 })
      })

      await waitFor(() => {
        expect(mockFindAllUsers).toHaveBeenCalledWith(
          expect.objectContaining({
            limit: 25,
            offset: 0,
          })
        )
      })
    })

    it('should handle pagination to page 3 with custom page size', async () => {
      mockFindAllUsers.mockResolvedValue({
        success: true,
        users: mockUsers,
        total: 100,
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.loading).toBe(false)
      })

      act(() => {
        result.current.handlePaginationChange({ page: 3, pageSize: 15 })
      })

      await waitFor(() => {
        expect(mockFindAllUsers).toHaveBeenCalledWith(
          expect.objectContaining({
            limit: 15,
            offset: 45, // page 3 * pageSize 15
          })
        )
      })
    })

    it('should set loading to true while fetching new page', async () => {
      mockFindAllUsers.mockResolvedValue({
        success: true,
        users: mockUsers,
        total: 2,
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.loading).toBe(false)
      })

      act(() => {
        result.current.handlePaginationChange({ page: 1, pageSize: 10 })
      })

      // Should be loading immediately after pagination change
      await waitFor(() => {
        expect(result.current.loading).toBe(true)
      })

      await waitFor(() => {
        expect(result.current.loading).toBe(false)
      })
    })

    it('should handle rapid pagination changes', async () => {
      mockFindAllUsers.mockResolvedValue({
        success: true,
        users: mockUsers,
        total: 100,
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.loading).toBe(false)
      })

      act(() => {
        result.current.handlePaginationChange({ page: 1, pageSize: 10 })
        result.current.handlePaginationChange({ page: 2, pageSize: 10 })
        result.current.handlePaginationChange({ page: 3, pageSize: 10 })
      })

      // Should eventually call with the last pagination model
      await waitFor(() => {
        expect(result.current.paginationModel).toEqual({ page: 3, pageSize: 10 })
      })
    })
  })

  describe('Search Handling', () => {
    it('should update search query when handleSearchChange is called', async () => {
      mockFindAllUsers.mockResolvedValue({
        success: true,
        users: mockUsers,
        total: 2,
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.loading).toBe(false)
      })

      act(() => {
        result.current.handleSearchChange('test query')
      })

      await waitFor(() => {
        expect(result.current.searchQuery).toBe('test query')
      })
    })

    it('should update search query with empty string', async () => {
      mockFindAllUsers.mockResolvedValue({
        success: true,
        users: mockUsers,
        total: 2,
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.loading).toBe(false)
      })

      act(() => {
        result.current.handleSearchChange('search')
      })

      expect(result.current.searchQuery).toBe('search')

      act(() => {
        result.current.handleSearchChange('')
      })

      expect(result.current.searchQuery).toBe('')
    })

    it('should handle special characters in search query', async () => {
      mockFindAllUsers.mockResolvedValue({
        success: true,
        users: mockUsers,
        total: 2,
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.loading).toBe(false)
      })

      act(() => {
        result.current.handleSearchChange('test@example.com')
      })

      expect(result.current.searchQuery).toBe('test@example.com')
    })

    it('should not trigger new fetch when search query changes', () => {
      mockFindAllUsers.mockResolvedValue({
        success: true,
        users: mockUsers,
        total: 2,
      })

      const { result } = renderHook(() => useAdminPage())

      expect(mockFindAllUsers).toHaveBeenCalledTimes(1)

      act(() => {
        result.current.handleSearchChange('search query')
      })

      // Search is client-side, so no new fetch

      expect(mockFindAllUsers).toHaveBeenCalledTimes(1)
    })

    it('should handle multiple rapid search changes', async () => {
      mockFindAllUsers.mockResolvedValue({
        success: true,
        users: mockUsers,
        total: 2,
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.loading).toBe(false)
      })

      act(() => {
        result.current.handleSearchChange('a')
        result.current.handleSearchChange('ad')
        result.current.handleSearchChange('adm')
        result.current.handleSearchChange('admin')
      })

      await waitFor(() => {
        expect(result.current.searchQuery).toBe('admin')
      })
    })
  })

  describe('Integration - Pagination and Data Fetching', () => {
    it('should preserve search query when pagination changes', async () => {
      mockFindAllUsers.mockResolvedValue({
        success: true,
        users: mockUsers,
        total: 2,
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.loading).toBe(false)
      })

      act(() => {
        result.current.handleSearchChange('test search')
      })

      await waitFor(() => {
        expect(result.current.searchQuery).toBe('test search')
      })

      act(() => {
        result.current.handlePaginationChange({ page: 1, pageSize: 10 })
      })

      await waitFor(() => {
        expect(result.current.loading).toBe(false)
      })

      expect(result.current.searchQuery).toBe('test search')
    })

    it('should maintain pagination model across failed fetches', async () => {
      mockFindAllUsers.mockResolvedValueOnce({
        success: true,
        users: mockUsers,
        total: 2,
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.loading).toBe(false)
      })

      mockFindAllUsers.mockResolvedValueOnce({
        success: false,
        users: [],
        total: 0,
        error: 'Network error',
      })

      act(() => {
        result.current.handlePaginationChange({ page: 1, pageSize: 20 })
      })

      await waitFor(() => {
        expect(result.current.loading).toBe(false)
      })

      await waitFor(() => {
        expect(result.current.paginationModel).toEqual({ page: 1, pageSize: 20 })
        expect(result.current.error).toBe('Network error')
      })
    })

    it('should handle successful fetch after failed fetch', async () => {
      mockFindAllUsers.mockResolvedValueOnce({
        success: false,
        users: [],
        total: 0,
        error: 'Initial error',
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.error).toBe('Initial error')
      })

      mockFindAllUsers.mockResolvedValueOnce({
        success: true,
        users: mockUsers,
        total: 2,
      })

      act(() => {
        result.current.handlePaginationChange({ page: 1, pageSize: 10 })
      })

      await waitFor(() => {
        expect(result.current.error).toBeNull()
        expect(result.current.users).toEqual(mockUsers)
      })
    })
  })

  describe('Edge Cases', () => {
    it('should handle pagination with page 0', async () => {
      mockFindAllUsers.mockResolvedValue({
        success: true,
        users: mockUsers,
        total: 2,
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.loading).toBe(false)
      })

      act(() => {
        result.current.handlePaginationChange({ page: 0, pageSize: 10 })
      })

      await waitFor(() => {
        expect(mockFindAllUsers).toHaveBeenCalledWith(
          expect.objectContaining({
            limit: 10,
            offset: 0,
          })
        )
      })
    })

    it('should handle very large page size', async () => {
      mockFindAllUsers.mockResolvedValue({
        success: true,
        users: mockUsers,
        total: 2,
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.loading).toBe(false)
      })

      act(() => {
        result.current.handlePaginationChange({ page: 0, pageSize: 1000 })
      })

      await waitFor(() => {
        expect(mockFindAllUsers).toHaveBeenCalledWith(
          expect.objectContaining({
            limit: 1000,
            offset: 0,
          })
        )
      })
    })

    it('should handle pageSize of 1', async () => {
      mockFindAllUsers.mockResolvedValue({
        success: true,
        users: [mockUsers[0]],
        total: 2,
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.loading).toBe(false)
      })

      act(() => {
        result.current.handlePaginationChange({ page: 0, pageSize: 1 })
      })

      await waitFor(() => {
        expect(mockFindAllUsers).toHaveBeenCalledWith(
          expect.objectContaining({
            limit: 1,
            offset: 0,
          })
        )
      })
    })

    it('should handle very long search query', async () => {
      mockFindAllUsers.mockResolvedValue({
        success: true,
        users: mockUsers,
        total: 2,
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.loading).toBe(false)
      })

      const longQuery = 'a'.repeat(1000)

      act(() => {
        result.current.handleSearchChange(longQuery)
      })

      await waitFor(() => {
        expect(result.current.searchQuery).toBe(longQuery)
      })
    })

    it('should handle search query with unicode characters', async () => {
      mockFindAllUsers.mockResolvedValue({
        success: true,
        users: mockUsers,
        total: 2,
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(result.current.loading).toBe(false)
      })

      act(() => {
        result.current.handleSearchChange('ç”¨æˆ·åç§° ðŸ”')
      })

      await waitFor(() => {
        expect(result.current.searchQuery).toBe('ç”¨æˆ·åç§° ðŸ”')
      })
    })
  })

  describe('AbortController Functionality', () => {
    it('should abort previous request when pagination changes rapidly', async () => {
      let firstCallSignal: AbortSignal | undefined
      let secondCallSignal: AbortSignal | undefined

      mockFindAllUsers
        .mockImplementationOnce(async (params) => {
          firstCallSignal = params.signal
          // Simulate slow request
          await new Promise((resolve) => setTimeout(resolve, 100))
          return {
            success: true,
            users: mockUsers,
            total: 2,
          }
        })
        .mockImplementationOnce(async (params) => {
          secondCallSignal = params.signal
          return {
            success: true,
            users: mockUsers,
            total: 2,
          }
        })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(mockFindAllUsers).toHaveBeenCalledTimes(1)
      })

      // Trigger rapid pagination change
      act(() => {
        result.current.handlePaginationChange({ page: 1, pageSize: 10 })
      })

      await waitFor(() => {
        expect(mockFindAllUsers).toHaveBeenCalledTimes(2)
      })

      // First request should have been aborted
      await waitFor(() => {
        expect(firstCallSignal?.aborted).toBe(true)
      })
      // Second request should not be aborted (yet)
      await waitFor(() => {
        expect(secondCallSignal?.aborted).toBe(false)
      })
    })

    it('should abort request on component unmount', async () => {
      let capturedSignal: AbortSignal | undefined

      mockFindAllUsers.mockImplementationOnce(async (params) => {
        capturedSignal = params.signal
        // Simulate slow request
        await new Promise((resolve) => setTimeout(resolve, 100))
        return {
          success: true,
          users: mockUsers,
          total: 2,
        }
      })

      const { unmount } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(mockFindAllUsers).toHaveBeenCalledTimes(1)
      })

      // Unmount the component
      unmount()

      // Signal should be aborted after unmount
      expect(capturedSignal?.aborted).toBe(true)
    })

    it('should not update state if request is aborted', async () => {
      mockFindAllUsers
        .mockImplementationOnce(async (params) => {
          // Check if signal is already aborted (real fetch throws immediately)
          if (params.signal?.aborted) {
            throw createAbortError()
          }

          // Simulate slow request that can be aborted
          await new Promise<void>((resolve, reject) => {
            const timeout = setTimeout(resolve, 100)

            // Listen for abort event during request (real fetch behavior)
            params.signal?.addEventListener(
              'abort',
              () => {
                clearTimeout(timeout)
                reject(createAbortError())
              },
              { once: true }
            )
          })

          return {
            success: true,
            users: [mockUsers[0]!],
            total: 1,
          }
        })
        .mockImplementationOnce(async () => {
          // Second request completes quickly
          return {
            success: true,
            users: [mockUsers[1]!],
            total: 1,
          }
        })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(mockFindAllUsers).toHaveBeenCalledTimes(1)
      })

      // Immediately trigger another pagination change (aborts first request)
      act(() => {
        result.current.handlePaginationChange({ page: 1, pageSize: 10 })
      })

      await waitFor(() => {
        expect(mockFindAllUsers).toHaveBeenCalledTimes(2)
      })

      await waitFor(() => {
        expect(result.current.loading).toBe(false)
      })

      // Should have data from second request, not first
      await waitFor(() => {
        expect(result.current.users).toHaveLength(1)
        expect(result.current.users[0]?.email).toBe('user@example.com')
      })
    })

    it('should handle multiple rapid pagination changes correctly', async () => {
      const signals: AbortSignal[] = []

      mockFindAllUsers.mockImplementation(async (params) => {
        signals.push(params.signal!)
        // Simulate request delay
        await new Promise((resolve) => setTimeout(resolve, 50))
        return {
          success: true,
          users: mockUsers,
          total: 10,
        }
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(mockFindAllUsers).toHaveBeenCalledTimes(1)
      })

      // Trigger multiple rapid pagination changes
      act(() => {
        result.current.handlePaginationChange({ page: 1, pageSize: 10 })
      })

      act(() => {
        result.current.handlePaginationChange({ page: 2, pageSize: 10 })
      })

      act(() => {
        result.current.handlePaginationChange({ page: 3, pageSize: 10 })
      })

      await waitFor(() => {
        expect(mockFindAllUsers).toHaveBeenCalledTimes(4)
      })

      // All previous signals should be aborted except the last one
      expect(signals[0]?.aborted).toBe(true)
      expect(signals[1]?.aborted).toBe(true)
      expect(signals[2]?.aborted).toBe(true)
      expect(signals[3]?.aborted).toBe(false)
    })

    it('should create new AbortController for each request', async () => {
      const signals: AbortSignal[] = []

      mockFindAllUsers.mockImplementation(async (params) => {
        signals.push(params.signal!)
        return {
          success: true,
          users: mockUsers,
          total: 2,
        }
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(mockFindAllUsers).toHaveBeenCalledTimes(1)
      })

      act(() => {
        result.current.handlePaginationChange({ page: 1, pageSize: 10 })
      })

      await waitFor(() => {
        expect(mockFindAllUsers).toHaveBeenCalledTimes(2)
      })

      // Each call should have a different AbortSignal instance
      expect(signals[0]).not.toBe(signals[1])
      expect(signals[0]).toBeDefined()
      expect(signals[1]).toBeDefined()
    })

    it('should pass signal parameter to findAllUsers', async () => {
      mockFindAllUsers.mockResolvedValueOnce({
        success: true,
        users: mockUsers,
        total: 2,
      })

      renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(mockFindAllUsers).toHaveBeenCalledTimes(1)
      })

      const callArgs = mockFindAllUsers.mock.calls[0]![0]
      expect(callArgs.signal).toBeInstanceOf(AbortSignal)
      expect(callArgs.signal?.aborted).toBe(false)
    })

    it('should abort on unmount even if request is pending', async () => {
      let requestSignal: AbortSignal | undefined

      mockFindAllUsers.mockImplementationOnce(async (params) => {
        requestSignal = params.signal
        // Never resolve this request
        await new Promise(() => {})
        return {
          success: true,
          users: mockUsers,
          total: 2,
        }
      })

      const { unmount } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(mockFindAllUsers).toHaveBeenCalledTimes(1)
      })

      // Request is still pending
      await waitFor(() => {
        expect(requestSignal?.aborted).toBe(false)
      })

      // Unmount component
      unmount()

      // Signal should now be aborted
      expect(requestSignal?.aborted).toBe(true)
    })

    it('should handle abort during pagination change sequence', async () => {
      let firstSignal: AbortSignal | undefined
      let secondSignal: AbortSignal | undefined

      mockFindAllUsers
        .mockImplementationOnce(async (params) => {
          firstSignal = params.signal
          await new Promise((resolve) => setTimeout(resolve, 200))
          return {
            success: true,
            users: [mockUsers[1]!],
            total: 1,
          }
        })
        .mockImplementationOnce(async (params) => {
          secondSignal = params.signal
          return {
            success: true,
            users: [mockUsers[0]!],
            total: 1,
          }
        })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(mockFindAllUsers).toHaveBeenCalledTimes(1)
      })

      // Start second request before first completes
      act(() => {
        result.current.handlePaginationChange({ page: 1, pageSize: 10 })
      })

      await waitFor(() => {
        expect(mockFindAllUsers).toHaveBeenCalledTimes(2)
      })

      // First signal should be aborted
      await waitFor(() => {
        expect(firstSignal?.aborted).toBe(true)
      })

      await waitFor(() => {
        expect(result.current.loading).toBe(false)
      })

      // Should show data from second request only
      await waitFor(() => {
        expect(result.current.users).toHaveLength(1)
        expect(result.current.users[0]?.email).toBe('admin@example.com')
        expect(secondSignal?.aborted).toBe(false)
      })
    })

    it('should maintain correct state after aborting multiple requests', async () => {
      let completedCalls = 0
      mockFindAllUsers.mockImplementation(async () => {
        completedCalls++
        await new Promise((resolve) => setTimeout(resolve, 50))
        // Return different data based on which call this is
        if (completedCalls === 1) {
          return { success: true, users: [mockUsers[0]!], total: 1 }
        } else if (completedCalls === 2) {
          return { success: true, users: [mockUsers[1]!], total: 1 }
        } else {
          return { success: true, users: [mockUsers[0]!], total: 1 }
        }
      })

      const { result } = renderHook(() => useAdminPage())

      await waitFor(() => {
        expect(mockFindAllUsers).toHaveBeenCalledTimes(1)
      })

      // Trigger rapid changes
      act(() => {
        result.current.handlePaginationChange({ page: 1, pageSize: 10 })
        result.current.handlePaginationChange({ page: 2, pageSize: 10 })
      })

      await waitFor(() => {
        expect(result.current.loading).toBe(false)
      })

      // Should have data from one of the requests (timing may vary)
      await waitFor(() => {
        expect(result.current.users).toHaveLength(1)
        // The final email could be from call 2 or call 3 due to race conditions
        expect(['admin@example.com', 'user@example.com']).toContain(result.current.users[0]?.email)
        expect(result.current.rowCount).toBe(1)
        expect(result.current.error).toBeNull()
      })
    })
  })
})
