AI NOTE: This document is adapted from the backend hexagonal architecture guide. However,
for Next.js / React 19 the architecture will never be exactly the same as a backend service.
The goal is to keep the same principles and ideas but adapt them to the frontend world.
The main architectural difference is that the frontend introduces a dedicated view layer
(for UI components and presentation logic) that does not exist in the backend.

Frontend-specific goals:
- Independence: Domain logic doesn't depend on frameworks or tools
- Replaceability: Adapters can be replaced without changing core logic
- End-to-end verification: The architecture still supports full request–response cycle tests
HEXAGONAL ARCHITECTURE OVERVIEW (Ports and Adapters Pattern)

The hexagonal architecture (also known as ports and adapters) organizes code
to isolate the core business logic from external concerns. This makes the
application more maintainable, testable, and adaptable to change.

CORE PRINCIPLES:

1. Dependency Rule: Dependencies point inward toward the domain
   Infrastructure → Adapters → Application → Domain
   
2. Ports: Interfaces that define how the application communicates
   - Primary/Driving Ports: How external world uses our application (use cases)
   - Secondary/Driven Ports: How our application uses external world (repositories)

3. Adapters: Concrete implementations of ports
   - Primary/Driving Adapters: HTTP controllers, CLI, GraphQL (inbound)
   - Secondary/Driven Adapters: Database repos, external APIs (outbound)

DIRECTORY STRUCTURE:

frontend/src/
├── app/                 # This is Next.js specific code mostly for pages
├── domain/              # Core business logic (center of hexagon)
│   ├── entities/        # Business objects with identity
│   ├── value-objects/   # Immutable domain concepts
│   ├── services/        # Domain services
│   └── events/          # Domain events
│
├── application/         # Use cases and orchestration
│   ├── use-cases/       # Application-specific business rules
│   ├── ports/           # Interface definitions (contracts)
│   └── dtos/            # Data transfer objects
│
├── adapters/            # Implementations of ports
│   ├── primary/         # Inbound adapters (HTTP, CLI, etc.)
│   │   └── http/        # Fastify controllers
│   └── secondary/       # Outbound adapters (DB, external services)
│       ├── repositories/
│       ├── services/
│       └── external/
│
├── infrastructure/      # Technical implementation details
│   ├── serveractions/   # Calling APIs from the backend
│   ├── config/          # Environment configuration
│   ├── security/        # Auth, encryption
│   └── di/              # Dependency injection
│
├── view/                # Technical implementation of UI
│   ├── client-components/      # UI client-side components
│   ├── server-components/      # UI server-side components
│   ├── hooks/           # Hooks for data fetching and state management
│
└── shared/              # Common utilities across layers
    ├── types/
    ├── utils/
    ├── constants/
    ├── exceptions/
    └── guards/

BENEFITS:

✓ Testability: Domain and application can be tested without infrastructure
✓ Flexibility: Easy to swap databases, frameworks, or external services
✓ Maintainability: Clear separation of concerns
✓ Independence: Domain logic doesn't depend on frameworks or tools
✓ Replaceability: Adapters can be replaced without changing core logic

DEPENDENCY FLOW:

External Request → Primary Adapter (HTTP Controller)
                → Application Use Case
                → Domain Entity/Service
                → Secondary Port Interface (Repository)
                → Secondary Adapter (PostgreSQL Repository)
                → Database

TESTING STRATEGY:

- Domain: Unit tests (pure functions, no mocks needed)
- Application: Unit tests with mocked ports
- Adapters: Integration tests with real infrastructure
- End-to-End: Full request-response cycle tests
